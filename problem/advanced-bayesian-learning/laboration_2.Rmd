---
title: 'Lobaration 2'
output: html_document
---

```{r, message = FALSE}
library(tidyverse)

theme_set(theme_minimal())
```

```{r}
url <- 'https://raw.githubusercontent.com/mattiasvillani/AdvBayesLearnCourse/master/Labs/GalaxyData.dat'
data <- readr::read_table(url, col_names = c('x'), col_types = list(x = 'd'))
```

```{r}
data %>%
  ggplot(aes(x)) +
  stat_ecdf() +
  labs(x = 'Velocity', y = 'Empirical CDF')
```

# Direct prior

```{r}
stick_break <- function(l, alpha, beta) {
  q <- rbeta(l, shape1 = alpha, shape2 = beta)
  q <- c(head(q, -1), 1)
  q * c(1, cumprod(1 - head(q, -1)))
}

nu_prior <- function(nu0 = 1, mu0 = 20, sigma0 = 3) {
  sample_P0 <- function(l) rnorm(l, mean = mu0, sd = sigma0)
  list(sample_P0 = sample_P0, nu0 = nu0)
}

nu_posterior <- function(x, nu0 = 1, mu0 = 20, sigma0 = 3) {
  prior <- nu_prior(nu0 = nu0, mu0 = mu0, sigma0 = sigma0)
  sample_P0 <- function(l) {
    i <- rbernoulli(l, p = nu0 / (nu0 + length(x)))
    i * prior$sample_P0(l) + (1 - i) * sample(x, l, replace = TRUE)
  }
  list(sample_P0 = sample_P0, nu0 = nu0 + length(x))
}

sample_nu <- function(l, nu) {
  x <- nu$sample_P0(l)
  p <- stick_break(l, 1, nu$nu0)
  tibble(x = x, p = p)
}

plot_distribution <- function(sample, reference) {
  sample <- sample %>%
    arrange(x) %>%
    mutate(p = cumsum(p))
  ggplot() +
    geom_line(data = sample, mapping = aes(x, p), color = 'gray70') +
    stat_ecdf(data = reference, mapping = aes(x)) +
    labs(x = 'Velocity', y = 'Sample CDF')
}
```

```{r, fig.asp = 1}
set.seed(42)

tibble(nu0 = c(1, 10, 100)) %>%
  mutate(data = map(nu0, ~ sample_nu(l = 10000, nu = nu_prior(.x)))) %>%
  unnest(data) %>%
  mutate(nu0 = str_c('Prior volume = ', nu0)) %>%
  group_by(nu0) %>%
  plot_distribution(data) +
  facet_wrap(vars(nu0), ncol = 1)
```

```{r, fig.asp = 1}
set.seed(42)

tibble(nu0 = c(1, 10, 100)) %>%
  mutate(data = map(nu0, ~ sample_nu(l = 10000,
                                     nu = nu_posterior(data$x, .x)))) %>%
  unnest(data) %>%
  mutate(nu0 = str_c('Prior volume = ', nu0)) %>%
  group_by(nu0) %>%
  plot_distribution(data) +
  facet_wrap(vars(nu0), ncol = 1)
```

# Mixing prior

```{r}
data %>%
  ggplot(aes(x)) +
  geom_dotplot(method = 'histodot', binwidth = 1, dotsize = 0.8) +
  labs(x = 'Velocity', y = 'Observations') +
  theme(axis.text.y = element_blank())
```

```{r}
sample_P0_prior <- function(l, mu0 = 20, n0 = 1, alpha0 = 1, beta0 = 0.5) {
  tau <- rgamma(l, alpha0, beta0)
  mu <- rnorm(l, mu0, n0 * tau)
  tibble(mu = mu, tau = tau)
}

sample_P0_posterior <- function(l, x, mu0 = 20, n0 = 1, alpha0 = 1, beta0 = 0.5) {
  n1 <- length(x)
  if (n1 == 0) {
    mu1 <- 0
    s1 <- 0
  } else {
    mu1 <- mean(x)
    s1 <- sum((x - mu1)^2) / n1
  }
  sample_P0_prior(
    l = l,
    mu0 = n0 * mu0 / (n0 + n1) + n1 * mu1 / (n0 + n1),
    n0 = n0 + n1,
    alpha0 = alpha0 + n1 / 2,
    beta0 = beta0 + 0.5 * (n0 * n1 * (mu1 - mu0)^2 / (n0 + n1) + n1 * s1)
  )
}

evaluate_P1 <- function(x, theta) {
  pnorm(x, theta$mu, sqrt(1 / theta$tau))
}

update_k <- function(x, state) {
  m <- length(state$p)
  n <- length(x)
  p <- rep(state$p, n)
  x <- rep(x, each = m)
  theta <- state$theta %>% slice(rep(1:m, n))
  p <- matrix(p * evaluate_P1(x, theta), nrow = m, ncol = n)
  p <- p / colSums(p)
  apply(p, 2, function(p) sample(1:m, 1, prob = p))
}

update_p <- function(x, state, nu0 = 1) {
  m <- length(state$p)
  n <- rep(0, m)
  k <- as.data.frame(table(state$k))
  n[as.numeric(levels(k[ , 1]))[k[ , 1]]] <- k[ , 2]
  alpha <- 1 + n
  beta <- nu0 + cumsum(c(n[-1], 0))
  stick_break(m, alpha, beta)
}

update_theta <- function(x, state) {
  m <- length(state$p)
  sapply(1:m, function(i) sample_P0_posterior(1, x[state$k == i]),
         simplify = FALSE) %>%
    bind_rows()
}
```

```{r}
sample_P0_prior(1000) %>%
  ggplot() +
  geom_density(aes(mu))
```

```{r}
sample_P0_posterior(1000, data$x) %>%
  ggplot() +
  geom_density(aes(mu))
```

```{r}
set.seed(42)

m <- 50
L <- 1000

state <- list(
  p = rep(1 / m, m),
  k = sample(1:m, nrow(data), replace = TRUE),
  theta = tibble(mu = rep(mean(data$x), m),
                 tau = rep(1 / var(data$x), m))
)

draws <- vector('list', L)
for(i in 1:L) {
  state$k <- update_k(data$x, state)
  state$p <- update_p(data$x, state)
  state$theta <- update_theta(data$x, state)
  draws[[i]] <- state
}
```

```{r}
tibble(value = sapply(draws, function(draw) length(unique(draw$k)))) %>%
  mutate(draw = row_number()) %>%
  ggplot(aes(draw, value)) +
  geom_line(size = 0.1)
```

```{r}
evaluate_P2_ <- function(draw, grid, method = 'distribution') {
  if (method == 'density') {
    method = dnorm
  } else if (method == 'distribution') {
    method = pnorm
  }
  bind_cols(draw$theta, tibble(p = draw$p)) %>%
    mutate(.component = row_number()) %>%
    select(.component, everything()) %>%
    mutate(data = map2(mu, tau, function(mu, tau) {
                                  tibble(x = grid,
                                         y = method(grid, mean = mu, sd = sqrt(1 / tau)))
                                })) %>%
    unnest(data) %>%
    group_by(x) %>%
    summarize(y = sum(p * y), .groups = 'drop')
}

evaluate_P2 <- function(draws, grid, ...) {
  process <- function(i) {
    evaluate_P2_(draws[[i]], grid, ...) %>%
      mutate(.draw = i) %>%
      select(.draw, everything())
  }
  sapply(1:length(draws), process, simplify = FALSE) %>%
    bind_rows()
}

predictive_check <- function(draws, reference, size = 1000) {
  grid <- seq(min(reference$x), to = max(reference$x), length.out = size)
  sample <- evaluate_P2(draws, grid)
  ggplot() +
    stat_ecdf(data = reference, mapping = aes(x)) +
    geom_line(data = sample, mapping = aes(x, y, group = .draw), alpha = 0.1)
}
```

```{r}
evaluate_P2_(list(p = c(0.3, 0.7), theta = tibble(mu = c(-5, 5), tau = c(1, 1))),
             seq(-10, to = 10, length.out = 1000),
             method = 'density') %>%
  ggplot(aes(x, y)) +
  geom_line()
```

```{r}
set.seed(42)

predictive_check(sample(tail(draws, L / 2), 10), data)
```
